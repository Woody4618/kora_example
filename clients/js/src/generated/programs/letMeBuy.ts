/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
  SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
  SolanaError,
  type Address,
  type ClientWithRpc,
  type ClientWithTransactionPlanning,
  type ClientWithTransactionSending,
  type GetAccountInfoApi,
  type GetMultipleAccountsApi,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  addSelfFetchFunctions,
  addSelfPlanAndSendFunctions,
  type SelfFetchFunctions,
  type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import {
  getReceiptsCodec,
  type Receipts,
  type ReceiptsArgs,
} from "../accounts";
import {
  getAddProductInstructionAsync,
  getDeleteProductInstructionAsync,
  getDeleteStoreInstructionAsync,
  getInitializeInstructionAsync,
  getMakePurchaseInstructionAsync,
  getMarkAsDeliveredInstructionAsync,
  getUpdateDetailsInstructionAsync,
  getUpdateTelegramChannelInstructionAsync,
  parseAddProductInstruction,
  parseDeleteProductInstruction,
  parseDeleteStoreInstruction,
  parseInitializeInstruction,
  parseMakePurchaseInstruction,
  parseMarkAsDeliveredInstruction,
  parseUpdateDetailsInstruction,
  parseUpdateTelegramChannelInstruction,
  type AddProductAsyncInput,
  type DeleteProductAsyncInput,
  type DeleteStoreAsyncInput,
  type InitializeAsyncInput,
  type MakePurchaseAsyncInput,
  type MarkAsDeliveredAsyncInput,
  type ParsedAddProductInstruction,
  type ParsedDeleteProductInstruction,
  type ParsedDeleteStoreInstruction,
  type ParsedInitializeInstruction,
  type ParsedMakePurchaseInstruction,
  type ParsedMarkAsDeliveredInstruction,
  type ParsedUpdateDetailsInstruction,
  type ParsedUpdateTelegramChannelInstruction,
  type UpdateDetailsAsyncInput,
  type UpdateTelegramChannelAsyncInput,
} from "../instructions";

export const LET_ME_BUY_PROGRAM_ADDRESS =
  "BUYuxRfhCMWavaUWxhGtPP3ksKEDZxCD5gzknk3JfAya" as Address<"BUYuxRfhCMWavaUWxhGtPP3ksKEDZxCD5gzknk3JfAya">;

export enum LetMeBuyAccount {
  Receipts,
}

export function identifyLetMeBuyAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LetMeBuyAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([222, 245, 237, 64, 59, 49, 29, 246]),
      ),
      0,
    )
  ) {
    return LetMeBuyAccount.Receipts;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    { accountData: data, programName: "letMeBuy" },
  );
}

export enum LetMeBuyInstruction {
  AddProduct,
  DeleteProduct,
  DeleteStore,
  Initialize,
  MakePurchase,
  MarkAsDelivered,
  UpdateDetails,
  UpdateTelegramChannel,
}

export function identifyLetMeBuyInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LetMeBuyInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([0, 219, 137, 36, 105, 180, 164, 93]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.AddProduct;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([173, 212, 141, 230, 33, 82, 166, 25]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.DeleteProduct;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([150, 83, 75, 192, 195, 29, 178, 183]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.DeleteStore;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([193, 62, 227, 136, 105, 212, 201, 20]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.MakePurchase;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([112, 46, 230, 68, 152, 97, 194, 62]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.MarkAsDelivered;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([245, 102, 156, 21, 212, 18, 54, 13]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.UpdateDetails;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([125, 26, 242, 114, 17, 12, 103, 200]),
      ),
      0,
    )
  ) {
    return LetMeBuyInstruction.UpdateTelegramChannel;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    { instructionData: data, programName: "letMeBuy" },
  );
}

export type ParsedLetMeBuyInstruction<
  TProgram extends string = "BUYuxRfhCMWavaUWxhGtPP3ksKEDZxCD5gzknk3JfAya",
> =
  | ({
      instructionType: LetMeBuyInstruction.AddProduct;
    } & ParsedAddProductInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.DeleteProduct;
    } & ParsedDeleteProductInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.DeleteStore;
    } & ParsedDeleteStoreInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.MakePurchase;
    } & ParsedMakePurchaseInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.MarkAsDelivered;
    } & ParsedMarkAsDeliveredInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.UpdateDetails;
    } & ParsedUpdateDetailsInstruction<TProgram>)
  | ({
      instructionType: LetMeBuyInstruction.UpdateTelegramChannel;
    } & ParsedUpdateTelegramChannelInstruction<TProgram>);

export function parseLetMeBuyInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedLetMeBuyInstruction<TProgram> {
  const instructionType = identifyLetMeBuyInstruction(instruction);
  switch (instructionType) {
    case LetMeBuyInstruction.AddProduct: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.AddProduct,
        ...parseAddProductInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.DeleteProduct: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.DeleteProduct,
        ...parseDeleteProductInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.DeleteStore: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.DeleteStore,
        ...parseDeleteStoreInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.Initialize: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.Initialize,
        ...parseInitializeInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.MakePurchase: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.MakePurchase,
        ...parseMakePurchaseInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.MarkAsDelivered: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.MarkAsDelivered,
        ...parseMarkAsDeliveredInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.UpdateDetails: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.UpdateDetails,
        ...parseUpdateDetailsInstruction(instruction),
      };
    }
    case LetMeBuyInstruction.UpdateTelegramChannel: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: LetMeBuyInstruction.UpdateTelegramChannel,
        ...parseUpdateTelegramChannelInstruction(instruction),
      };
    }
    default:
      throw new SolanaError(
        SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
        { instructionType: instructionType as string, programName: "letMeBuy" },
      );
  }
}

export type LetMeBuyPlugin = {
  accounts: LetMeBuyPluginAccounts;
  instructions: LetMeBuyPluginInstructions;
};

export type LetMeBuyPluginAccounts = {
  receipts: ReturnType<typeof getReceiptsCodec> &
    SelfFetchFunctions<ReceiptsArgs, Receipts>;
};

export type LetMeBuyPluginInstructions = {
  addProduct: (
    input: AddProductAsyncInput,
  ) => ReturnType<typeof getAddProductInstructionAsync> &
    SelfPlanAndSendFunctions;
  deleteProduct: (
    input: DeleteProductAsyncInput,
  ) => ReturnType<typeof getDeleteProductInstructionAsync> &
    SelfPlanAndSendFunctions;
  deleteStore: (
    input: DeleteStoreAsyncInput,
  ) => ReturnType<typeof getDeleteStoreInstructionAsync> &
    SelfPlanAndSendFunctions;
  initialize: (
    input: InitializeAsyncInput,
  ) => ReturnType<typeof getInitializeInstructionAsync> &
    SelfPlanAndSendFunctions;
  makePurchase: (
    input: MakePurchaseAsyncInput,
  ) => ReturnType<typeof getMakePurchaseInstructionAsync> &
    SelfPlanAndSendFunctions;
  markAsDelivered: (
    input: MarkAsDeliveredAsyncInput,
  ) => ReturnType<typeof getMarkAsDeliveredInstructionAsync> &
    SelfPlanAndSendFunctions;
  updateDetails: (
    input: UpdateDetailsAsyncInput,
  ) => ReturnType<typeof getUpdateDetailsInstructionAsync> &
    SelfPlanAndSendFunctions;
  updateTelegramChannel: (
    input: UpdateTelegramChannelAsyncInput,
  ) => ReturnType<typeof getUpdateTelegramChannelInstructionAsync> &
    SelfPlanAndSendFunctions;
};

export type LetMeBuyPluginRequirements = ClientWithRpc<
  GetAccountInfoApi & GetMultipleAccountsApi
> &
  ClientWithTransactionPlanning &
  ClientWithTransactionSending;

export function letMeBuyProgram() {
  return <T extends LetMeBuyPluginRequirements>(client: T) => {
    return {
      ...client,
      letMeBuy: <LetMeBuyPlugin>{
        accounts: {
          receipts: addSelfFetchFunctions(client, getReceiptsCodec()),
        },
        instructions: {
          addProduct: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getAddProductInstructionAsync(input),
            ),
          deleteProduct: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getDeleteProductInstructionAsync(input),
            ),
          deleteStore: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getDeleteStoreInstructionAsync(input),
            ),
          initialize: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getInitializeInstructionAsync(input),
            ),
          makePurchase: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMakePurchaseInstructionAsync(input),
            ),
          markAsDelivered: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMarkAsDeliveredInstructionAsync(input),
            ),
          updateDetails: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getUpdateDetailsInstructionAsync(input),
            ),
          updateTelegramChannel: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getUpdateTelegramChannelInstructionAsync(input),
            ),
        },
      },
    };
  };
}
